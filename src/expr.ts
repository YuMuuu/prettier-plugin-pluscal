//note: 以下のscriptでexpr一覧を取得
// import nodeTypes from '@tlaplus/tree-sitter-tlaplus/src/node-types.json'
// const arr = nodeTypes.map(e => e.type)
// const util = require('util');
// console.log(util.inspect(arr, { maxArrayLength: null }));

const exprLiteralList = [
  "_expr",
  "_number",
  "_number_set",
  "_op",
  "_primitive_value_set",
  "_proof",
  "_unit",
  "address",
  "all_map_to",
  "always",
  "approx",
  "assign",
  "assume_prove",
  "assumption",
  "asymp",
  "bigcirc",
  "binary_number",
  "block_comment",
  "block_comment_text",
  "bnf_rule",
  "boolean",
  "bound_infix_op",
  "bound_nonfix_op",
  "bound_op",
  "bound_postfix_op",
  "bound_prefix_op",
  "bounded_quantification",
  "bullet",
  "bullet_conj",
  "bullet_disj",
  "cap",
  "case",
  "case_arm",
  "case_arrow",
  "case_box",
  "case_proof_step",
  "cdot",
  "child_id",
  "choose",
  "circ",
  "colon",
  "cong",
  "conj_item",
  "conj_list",
  "constant_declaration",
  "cup",
  "def_eq",
  "definition_proof_step",
  "disj_item",
  "disj_list",
  "div",
  "domain",
  "doteq",
  "dots_2",
  "dots_3",
  "double_line",
  "enabled",
  "eq",
  "equiv",
  "eventually",
  "except",
  "except_update",
  "except_update_fn_appl",
  "except_update_record_field",
  "except_update_specifier",
  "excl",
  "exists",
  "extends",
  "fair",
  "fairness",
  "finite_set_literal",
  "forall",
  "function_definition",
  "function_evaluation",
  "function_literal",
  "geq",
  "gets",
  "gg",
  "have_proof_step",
  "header_line",
  "hex_number",
  "if_then_else",
  "iff",
  "implies",
  "in",
  "infix_op_symbol",
  "inner_assume_prove",
  "instance",
  "int_number_set",
  "label",
  "label_as",
  "lambda",
  "land",
  "langle_bracket",
  "ld_ttile",
  "leads_to",
  "leq",
  "let_in",
  "ll",
  "lnot",
  "local_definition",
  "lor",
  "ls_ttile",
  "lt",
  "maps_to",
  "minus",
  "module",
  "module_definition",
  "module_ref",
  "nat_number",
  "nat_number_set",
  "negative",
  "neq",
  "new",
  "non_terminal_proof",
  "notin",
  "octal_number",
  "odot",
  "ominus",
  "operator_args",
  "operator_declaration",
  "operator_definition",
  "oplus",
  "oslash",
  "other_arm",
  "otimes",
  "parentheses",
  "pcal_algorithm",
  "pcal_algorithm_body",
  "pcal_algorithm_start",
  "pcal_assert",
  "pcal_assign",
  "pcal_await",
  "pcal_definitions",
  "pcal_either",
  "pcal_goto",
  "pcal_if",
  "pcal_lhs",
  "pcal_macro",
  "pcal_macro_call",
  "pcal_macro_decl",
  "pcal_print",
  "pcal_proc_call",
  "pcal_proc_decl",
  "pcal_proc_var_decl",
  "pcal_proc_var_decls",
  "pcal_procedure",
  "pcal_process",
  "pcal_return",
  "pcal_skip",
  "pcal_var_decl",
  "pcal_var_decls",
  "pcal_while",
  "pcal_with",
  "pick_proof_step",
  "plus",
  "plus_arrow",
  "postfix_op_symbol",
  "powerset",
  "prec",
  "preceq",
  "prefix_op_symbol",
  "prefixed_op",
  "prev_func_val",
  "proof_step",
  "proof_step_id",
  "proof_step_ref",
  "propto",
  "qed_step",
  "qq",
  "quantifier_bound",
  "rangle_bracket",
  "rangle_bracket_sub",
  "rd_ttile",
  "real_number_set",
  "record_literal",
  "record_value",
  "recursive_declaration",
  "rs_ttile",
  "set_filter",
  "set_in",
  "set_map",
  "set_of_functions",
  "set_of_records",
  "sim",
  "simeq",
  "single_line", //implimented
  "source_file",
  "sqcap",
  "sqcup",
  "sqsubset",
  "sqsubseteq",
  "sqsupset",
  "sqsupseteq",
  "star",
  "statement_level",
  "step_expr_no_stutter",
  "step_expr_or_stutter",
  "string",
  "subexpr_component",
  "subexpr_prefix",
  "subexpr_tree_nav",
  "subexpression",
  "subset",
  "subseteq",
  "substitution",
  "succ",
  "succeq",
  "suffices_proof_step",
  "sup_plus",
  "supset",
  "supseteq",
  "take_proof_step",
  "temporal_exists",
  "temporal_forall",
  "terminal_proof",
  "theorem",
  "times",
  "tuple_literal",
  "tuple_of_identifiers",
  "unbounded_quantification",
  "unchanged",
  "union",
  "uplus",
  "use_body",
  "use_body_def",
  "use_body_expr",
  "use_or_hide",
  "variable_declaration",
  "vertvert",
  "witness_proof_step",
  "wr",
  "!",
  "!!",
  '"',
  "#",
  "(",
  "(*",
  "(+)",
  "(-)",
  "(.)",
  "(/)",
  "(\\X)",
  ")",
  "*)",
  "+",
  ",",
  "-",
  "-+->",
  "----",
  "--algorithm",
  "--fair",
  "->",
  "-|",
  ".",
  "..",
  "...",
  "/=",
  "/\\",
  ":",
  "::",
  "::=",
  ":=",
  ";",
  "<",
  "<-",
  "<<",
  "<=",
  "<=>",
  "<>",
  "=",
  "=<",
  "==",
  "====",
  "=>",
  "=|",
  ">",
  ">=",
  ">>",
  ">>_",
  "??",
  "@",
  "ACTION",
  "ASSUME",
  "ASSUMPTION",
  "AXIOM",
  "BY",
  "CASE",
  "CHOOSE",
  "CONSTANT",
  "CONSTANTS",
  "COROLLARY",
  "DEF",
  "DEFINE",
  "DEFS",
  "DOMAIN",
  "ELSE",
  "ENABLED",
  "EXCEPT",
  "EXTENDS",
  "FALSE",
  "HAVE",
  "HIDE",
  "IF",
  "IN",
  "INSTANCE",
  "Int",
  "LAMBDA",
  "LEMMA",
  "LET",
  "LOCAL",
  "MODULE", //implimented
  "NEW",
  "Nat",
  "OBVIOUS",
  "OMITTED",
  "ONLY",
  "OTHER",
  "PICK",
  "PROOF",
  "PROPOSITION",
  "PROVE",
  "QED",
  "RECURSIVE",
  "Real",
  "SF_",
  "STATE",
  "SUBSET",
  "SUFFICES",
  "TAKE",
  "TEMPORAL",
  "THEN",
  "THEOREM",
  "TRUE",
  "UNCHANGED",
  "UNION",
  "USE",
  "VARIABLE",
  "VARIABLES",
  "WF_",
  "WITH",
  "WITNESS",
  "[",
  "[]",
  "\\/",
  "\\A",
  "\\AA",
  "\\E",
  "\\EE",
  "\\X",
  "\\approx",
  "\\asymp",
  "\\bigcirc",
  "\\bullet",
  "\\cap",
  "\\cdot",
  "\\circ",
  "\\cong",
  "\\cup",
  "\\div",
  "\\doteq",
  "\\equiv",
  "\\exists",
  "\\forall",
  "\\geq",
  "\\gg",
  "\\in",
  "\\intersect",
  "\\land",
  "\\leq",
  "\\ll",
  "\\lnot",
  "\\lor",
  "\\neg",
  "\\notin",
  "\\o",
  "\\odot",
  "\\ominus",
  "\\oplus",
  "\\oslash",
  "\\otimes",
  "\\prec",
  "\\preceq",
  "\\propto",
  "\\sim",
  "\\simeq",
  "\\sqcap",
  "\\sqcup",
  "\\sqsubset",
  "\\sqsubseteq",
  "\\sqsupset",
  "\\sqsupseteq",
  "\\star",
  "\\subset",
  "\\subseteq",
  "\\succ",
  "\\succeq",
  "\\supset",
  "\\supseteq",
  "\\times",
  "\\union",
  "\\uplus",
  "\\wr",
  "]",
  "]_",
  "^+",
  "algorithm",
  "amp",
  "ampamp",
  "assert",
  "asterisk",
  "await",
  "begin",
  "boolean_set",
  "call",
  "comment",
  "compose",
  "define",
  "do",
  "dol",
  "doldol",
  "either",
  "else",
  "elsif",
  "end",
  "escape_char",
  "extramodular_text",
  "fair",
  "format",
  "goto",
  "gt",
  "hashhash",
  "identifier", //implimented
  "identifier_ref",
  "if",
  "level",
  "macro",
  "map_from",
  "map_to",
  "minusminus",
  "mod",
  "modmod",
  "mul",
  "mulmul",
  "name",
  "or",
  "pcal_end_either",
  "pcal_end_if",
  "pcal_end_while",
  "pcal_end_with",
  "placeholder",
  "plusplus",
  "pow",
  "powpow",
  "prime",
  "print",
  "procedure",
  "process",
  "real_number",
  "return",
  "setminus",
  "skip",
  "slash",
  "slashslash",
  "string_set",
  "sup_hash",
  "then",
  "value",
  "variable",
  "variables",
  "vert",
  "when",
  "while",
  "with",
  "{",
  "|-",
  "|->",
  "|=",
  "||",
  "}",
  "~",
  "~>",
  "¬",
  "×",
  "÷",
  "‖",
  "‥",
  "…",
  "‼",
  "⁇",
  "⁺",
  "ℕ",
  "ℝ",
  "ℤ",
  "←",
  "→",
  "↝",
  "↦",
  "⇒",
  "⇔",
  "⇝",
  "⇸",
  "∀",
  "∃",
  "∈",
  "∉",
  "∘",
  "∝",
  "∧",
  "∨",
  "∩",
  "∪",
  "∷",
  "∼",
  "≀",
  "≃",
  "≅",
  "≈",
  "≍",
  "≐",
  "≔",
  "≜",
  "≠",
  "≡",
  "≤",
  "≥",
  "≪",
  "≫",
  "≺",
  "≻",
  "⊂",
  "⊃",
  "⊆",
  "⊇",
  "⊎",
  "⊏",
  "⊐",
  "⊑",
  "⊒",
  "⊓",
  "⊔",
  "⊕",
  "⊖",
  "⊗",
  "⊘",
  "⊙",
  "⊢",
  "⊣",
  "⊨",
  "⋄",
  "⋅",
  "⋆",
  "□",
  "◇",
  "●",
  "◯",
  "⟨",
  "⟩",
  "⟩_",
  "⟵",
  "⟶",
  "⟹",
  "⟺",
  "⟼",
  "⥅",
  "⩴",
  "⪯",
  "⪰",
  "⫤",
  "〈",
  "〉",
  "〉_",
] as const;

type ExprLiteralUnion = (typeof exprLiteralList)[number];

// export  {exprLiteralList, exprLiteralUnion}
