//note: 以下のscriptでexpr一覧を取得
// import nodeTypes from '@tlaplus/tree-sitter-tlaplus/src/node-types.json'
// const arr = nodeTypes.map(e => e.type) 
// const util = require('util');
// console.log(util.inspect(arr, { maxArrayLength: null }));

const exprLiteralList = [
    '_expr',
    '_number',
    '_number_set',
    '_op',
    '_primitive_value_set',
    '_proof',
    '_unit',
    'address',
    'all_map_to',
    'always',
    'approx',
    'assign',
    'assume_prove',
    'assumption',
    'asymp',
    'bigcirc',
    'binary_number',
    'block_comment',
    'block_comment_text',
    'bnf_rule',
    'boolean',
    'bound_infix_op',
    'bound_nonfix_op',
    'bound_op',
    'bound_postfix_op',
    'bound_prefix_op',
    'bounded_quantification',
    'bullet',
    'bullet_conj',
    'bullet_disj',
    'cap',
    'case',
    'case_arm',
    'case_arrow',
    'case_box',
    'case_proof_step',
    'cdot',
    'child_id',
    'choose',
    'circ',
    'colon',
    'cong',
    'conj_item',
    'conj_list',
    'constant_declaration',
    'cup',
    'def_eq',
    'definition_proof_step',
    'disj_item',
    'disj_list',
    'div',
    'domain',
    'doteq',
    'dots_2',
    'dots_3',
    'double_line',
    'enabled',
    'eq',
    'equiv',
    'eventually',
    'except',
    'except_update',
    'except_update_fn_appl',
    'except_update_record_field',
    'except_update_specifier',
    'excl',
    'exists',
    'extends',
    'fair',
    'fairness',
    'finite_set_literal',
    'forall',
    'function_definition',
    'function_evaluation',
    'function_literal',
    'geq',
    'gets',
    'gg',
    'have_proof_step',
    'header_line',
    'hex_number',
    'if_then_else',
    'iff',
    'implies',
    'in',
    'infix_op_symbol',
    'inner_assume_prove',
    'instance',
    'int_number_set',
    'label',
    'label_as',
    'lambda',
    'land',
    'langle_bracket',
    'ld_ttile',
    'leads_to',
    'leq',
    'let_in',
    'll',
    'lnot',
    'local_definition',
    'lor',
    'ls_ttile',
    'lt',
    'maps_to',
    'minus',
    'module',
    'module_definition',
    'module_ref',
    'nat_number',
    'nat_number_set',
    'negative',
    'neq',
    'new',
    'non_terminal_proof',
    'notin',
    'octal_number',
    'odot',
    'ominus',
    'operator_args',
    'operator_declaration',
    'operator_definition',
    'oplus',
    'oslash',
    'other_arm',
    'otimes',
    'parentheses',
    'pcal_algorithm',
    'pcal_algorithm_body',
    'pcal_algorithm_start',
    'pcal_assert',
    'pcal_assign',
    'pcal_await',
    'pcal_definitions',
    'pcal_either',
    'pcal_goto',
    'pcal_if',
    'pcal_lhs',
    'pcal_macro',
    'pcal_macro_call',
    'pcal_macro_decl',
    'pcal_print',
    'pcal_proc_call',
    'pcal_proc_decl',
    'pcal_proc_var_decl',
    'pcal_proc_var_decls',
    'pcal_procedure',
    'pcal_process',
    'pcal_return',
    'pcal_skip',
    'pcal_var_decl',
    'pcal_var_decls',
    'pcal_while',
    'pcal_with',
    'pick_proof_step',
    'plus',
    'plus_arrow',
    'postfix_op_symbol',
    'powerset',
    'prec',
    'preceq',
    'prefix_op_symbol',
    'prefixed_op',
    'prev_func_val',
    'proof_step',
    'proof_step_id',
    'proof_step_ref',
    'propto',
    'qed_step',
    'qq',
    'quantifier_bound',
    'rangle_bracket',
    'rangle_bracket_sub',
    'rd_ttile',
    'real_number_set',
    'record_literal',
    'record_value',
    'recursive_declaration',
    'rs_ttile',
    'set_filter',
    'set_in',
    'set_map',
    'set_of_functions',
    'set_of_records',
    'sim',
    'simeq',
    'single_line', //implimented
    'source_file',
    'sqcap',
    'sqcup',
    'sqsubset',
    'sqsubseteq',
    'sqsupset',
    'sqsupseteq',
    'star',
    'statement_level',
    'step_expr_no_stutter',
    'step_expr_or_stutter',
    'string',
    'subexpr_component',
    'subexpr_prefix',
    'subexpr_tree_nav',
    'subexpression',
    'subset',
    'subseteq',
    'substitution',
    'succ',
    'succeq',
    'suffices_proof_step',
    'sup_plus',
    'supset',
    'supseteq',
    'take_proof_step',
    'temporal_exists',
    'temporal_forall',
    'terminal_proof',
    'theorem',
    'times',
    'tuple_literal',
    'tuple_of_identifiers',
    'unbounded_quantification',
    'unchanged',
    'union',
    'uplus',
    'use_body',
    'use_body_def',
    'use_body_expr',
    'use_or_hide',
    'variable_declaration',
    'vertvert',
    'witness_proof_step',
    'wr',
    '!',
    '!!',
    '"',
    '#',
    '(',
    '(*',
    '(+)',
    '(-)',
    '(.)',
    '(/)',
    '(\\X)',
    ')',
    '*)',
    '+',
    ',',
    '-',
    '-+->',
    '----',
    '--algorithm',
    '--fair',
    '->',
    '-|',
    '.',
    '..',
    '...',
    '/=',
    '/\\',
    ':',
    '::',
    '::=',
    ':=',
    ';',
    '<',
    '<-',
    '<<',
    '<=',
    '<=>',
    '<>',
    '=',
    '=<',
    '==',
    '====',
    '=>',
    '=|',
    '>',
    '>=',
    '>>',
    '>>_',
    '??',
    '@',
    'ACTION',
    'ASSUME',
    'ASSUMPTION',
    'AXIOM',
    'BY',
    'CASE',
    'CHOOSE',
    'CONSTANT',
    'CONSTANTS',
    'COROLLARY',
    'DEF',
    'DEFINE',
    'DEFS',
    'DOMAIN',
    'ELSE',
    'ENABLED',
    'EXCEPT',
    'EXTENDS',
    'FALSE',
    'HAVE',
    'HIDE',
    'IF',
    'IN',
    'INSTANCE',
    'Int',
    'LAMBDA',
    'LEMMA',
    'LET',
    'LOCAL',
    'MODULE', //implimented
    'NEW',
    'Nat',
    'OBVIOUS',
    'OMITTED',
    'ONLY',
    'OTHER',
    'PICK',
    'PROOF',
    'PROPOSITION',
    'PROVE',
    'QED',
    'RECURSIVE',
    'Real',
    'SF_',
    'STATE',
    'SUBSET',
    'SUFFICES',
    'TAKE',
    'TEMPORAL',
    'THEN',
    'THEOREM',
    'TRUE',
    'UNCHANGED',
    'UNION',
    'USE',
    'VARIABLE',
    'VARIABLES',
    'WF_',
    'WITH',
    'WITNESS',
    '[',
    '[]',
    '\\/',
    '\\A',
    '\\AA',
    '\\E',
    '\\EE',
    '\\X',
    '\\approx',
    '\\asymp',
    '\\bigcirc',
    '\\bullet',
    '\\cap',
    '\\cdot',
    '\\circ',
    '\\cong',
    '\\cup',
    '\\div',
    '\\doteq',
    '\\equiv',
    '\\exists',
    '\\forall',
    '\\geq',
    '\\gg',
    '\\in',
    '\\intersect',
    '\\land',
    '\\leq',
    '\\ll',
    '\\lnot',
    '\\lor',
    '\\neg',
    '\\notin',
    '\\o',
    '\\odot',
    '\\ominus',
    '\\oplus',
    '\\oslash',
    '\\otimes',
    '\\prec',
    '\\preceq',
    '\\propto',
    '\\sim',
    '\\simeq',
    '\\sqcap',
    '\\sqcup',
    '\\sqsubset',
    '\\sqsubseteq',
    '\\sqsupset',
    '\\sqsupseteq',
    '\\star',
    '\\subset',
    '\\subseteq',
    '\\succ',
    '\\succeq',
    '\\supset',
    '\\supseteq',
    '\\times',
    '\\union',
    '\\uplus',
    '\\wr',
    ']',
    ']_',
    '^+',
    'algorithm',
    'amp',
    'ampamp',
    'assert',
    'asterisk',
    'await',
    'begin',
    'boolean_set',
    'call',
    'comment',
    'compose',
    'define',
    'do',
    'dol',
    'doldol',
    'either',
    'else',
    'elsif',
    'end',
    'escape_char',
    'extramodular_text',
    'fair',
    'format',
    'goto',
    'gt',
    'hashhash',
    'identifier', //implimented
    'identifier_ref',
    'if',
    'level',
    'macro',
    'map_from',
    'map_to',
    'minusminus',
    'mod',
    'modmod',
    'mul',
    'mulmul',
    'name',
    'or',
    'pcal_end_either',
    'pcal_end_if',
    'pcal_end_while',
    'pcal_end_with',
    'placeholder',
    'plusplus',
    'pow',
    'powpow',
    'prime',
    'print',
    'procedure',
    'process',
    'real_number',
    'return',
    'setminus',
    'skip',
    'slash',
    'slashslash',
    'string_set',
    'sup_hash',
    'then',
    'value',
    'variable',
    'variables',
    'vert',
    'when',
    'while',
    'with',
    '{',
    '|-',
    '|->',
    '|=',
    '||',
    '}',
    '~',
    '~>',
    '¬',
    '×',
    '÷',
    '‖',
    '‥',
    '…',
    '‼',
    '⁇',
    '⁺',
    'ℕ',
    'ℝ',
    'ℤ',
    '←',
    '→',
    '↝',
    '↦',
    '⇒',
    '⇔',
    '⇝',
    '⇸',
    '∀',
    '∃',
    '∈',
    '∉',
    '∘',
    '∝',
    '∧',
    '∨',
    '∩',
    '∪',
    '∷',
    '∼',
    '≀',
    '≃',
    '≅',
    '≈',
    '≍',
    '≐',
    '≔',
    '≜',
    '≠',
    '≡',
    '≤',
    '≥',
    '≪',
    '≫',
    '≺',
    '≻',
    '⊂',
    '⊃',
    '⊆',
    '⊇',
    '⊎',
    '⊏',
    '⊐',
    '⊑',
    '⊒',
    '⊓',
    '⊔',
    '⊕',
    '⊖',
    '⊗',
    '⊘',
    '⊙',
    '⊢',
    '⊣',
    '⊨',
    '⋄',
    '⋅',
    '⋆',
    '□',
    '◇',
    '●',
    '◯',
    '⟨',
    '⟩',
    '⟩_',
    '⟵',
    '⟶',
    '⟹',
    '⟺',
    '⟼',
    '⥅',
    '⩴',
    '⪯',
    '⪰',
    '⫤',
    '〈',
    '〉',
    '〉_'
  ] as const

type ExprLiteralUnion = typeof exprLiteralList[number]

// export  {exprLiteralList, exprLiteralUnion}